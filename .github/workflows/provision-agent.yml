name: Provision Agent

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Provisioning job ID'
        required: true
        type: string
      agent_id:
        description: 'Agent ID to provision'
        required: true
        type: string
      region:
        description: 'Deployment region (e.g. us-east, eu-central)'
        required: true
        type: string
      callback_url:
        description: 'URL to POST status callbacks to'
        required: true
        type: string

jobs:
  provision:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Tailscale on runner
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
          tags: tag:ci

      - name: Send provisioning callback
        run: |
          BODY='{"job_id":"${{ inputs.job_id }}","status":"provisioning","workflow_run_id":"${{ github.run_id }}"}'
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent provisioning callback for job ${{ inputs.job_id }}"

      - name: Heartbeat loop
        run: |
          # Send heartbeats every 60 seconds in background
          while true; do
            sleep 60
            BODY='{"job_id":"${{ inputs.job_id }}","type":"heartbeat"}'
            SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

            curl -sf -X POST "${{ inputs.callback_url }}" \
              -H "Content-Type: application/json" \
              -H "X-Signature: $SIGNATURE" \
              -d "$BODY" || true
          done &
          HEARTBEAT_PID=$!

          # Save PID for cleanup
          echo "$HEARTBEAT_PID" > /tmp/heartbeat_pid
          echo "Heartbeat loop started (PID: $HEARTBEAT_PID)"

      - name: Provision VM
        id: provision
        env:
          HETZNER_API_TOKEN: ${{ secrets.HETZNER_API_TOKEN }}
          HETZNER_SSH_KEY_ID: ${{ secrets.HETZNER_SSH_KEY_ID }}
          HETZNER_SNAPSHOT_ID: ${{ secrets.HETZNER_SNAPSHOT_ID }}
          TAILSCALE_OAUTH_CLIENT_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          TAILSCALE_OAUTH_CLIENT_SECRET: ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
          JOB_ID: ${{ inputs.job_id }}
          AGENT_ID: ${{ inputs.agent_id }}
          REGION: ${{ inputs.region }}
        run: npx tsx src/lib/provisioning/provision-vm.ts

      - name: Send VM created callback
        if: steps.provision.outcome == 'success'
        run: |
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "vm_created" \
            --arg used_snapshot "${{ steps.provision.outputs.used_snapshot }}" \
            '{job_id: $job_id, status: $status, step: $step, used_snapshot: $used_snapshot}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent vm_created step callback for job ${{ inputs.job_id }} (snapshot: ${{ steps.provision.outputs.used_snapshot }})"

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible

      - name: Install Ansible collections
        run: ansible-galaxy collection install -r src/ansible/requirements.yml

      - name: Configure SSH key for Ansible
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_PRIVATE_KEY }}" > /tmp/ansible_ssh_key
          chmod 600 /tmp/ansible_ssh_key

      - name: Generate Ansible inventory
        run: |
          cat > /tmp/inventory.yml <<EOF
          all:
            hosts:
              agent_vm:
                ansible_host: ${{ steps.provision.outputs.tailscale_ip }}
                ansible_user: root
                ansible_ssh_private_key_file: /tmp/ansible_ssh_key
                ansible_python_interpreter: /usr/bin/python3
            vars:
              agent_id: "${{ inputs.agent_id }}"
              server_name: "${{ steps.provision.outputs.server_name }}"
              server_id: "${{ steps.provision.outputs.server_id }}"
              api_url: "${{ secrets.AURA_API_URL }}"
          EOF

      - name: Send Ansible started callback
        run: |
          MODE="full"
          if [ "${{ steps.provision.outputs.used_snapshot }}" = "true" ]; then
            MODE="snapshot-hybrid"
          fi
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "ansible_started" \
            --arg mode "$MODE" \
            '{job_id: $job_id, status: $status, step: $step, mode: $mode}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent ansible_started step callback for job ${{ inputs.job_id }} (mode: $MODE)"

      - name: Configure VM with Ansible (Snapshot Mode)
        id: configure_snapshot
        if: steps.provision.outputs.used_snapshot == 'true'
        run: |
          echo "Using lightweight snapshot playbook..."
          ansible-playbook src/ansible/playbooks/configure-agent-snapshot.yml \
            -i /tmp/inventory.yml \
            --ssh-common-args='-o StrictHostKeyChecking=accept-new' \
            -vv

      - name: Configure VM with Ansible (Full Mode)
        id: configure_full
        if: steps.provision.outputs.used_snapshot != 'true'
        run: |
          echo "Using full configuration playbook..."
          ansible-playbook src/ansible/playbooks/configure-agent.yml \
            -i /tmp/inventory.yml \
            --ssh-common-args='-o StrictHostKeyChecking=accept-new' \
            -vv

      - name: Send Ansible complete callback
        if: success()
        run: |
          MODE="full"
          if [ "${{ steps.provision.outputs.used_snapshot }}" = "true" ]; then
            MODE="snapshot-hybrid"
          fi
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "ansible_complete" \
            --arg mode "$MODE" \
            '{job_id: $job_id, status: $status, step: $step, mode: $mode}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent ansible_complete step callback for job ${{ inputs.job_id }} (mode: $MODE)"

      - name: Stop heartbeat
        if: always()
        run: |
          if [ -f /tmp/heartbeat_pid ]; then
            kill $(cat /tmp/heartbeat_pid) 2>/dev/null || true
            echo "Heartbeat loop stopped"
          fi

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f /tmp/ansible_ssh_key
          rm -f /tmp/inventory.yml

      - name: Send success callback
        if: success()
        run: |
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "running" \
            --arg server_id "${{ steps.provision.outputs.server_id }}" \
            --arg server_ip "${{ steps.provision.outputs.server_ip }}" \
            --arg tailscale_ip "${{ steps.provision.outputs.tailscale_ip }}" \
            --arg used_snapshot "${{ steps.provision.outputs.used_snapshot }}" \
            '{job_id: $job_id, status: $status, server_id: $server_id, server_ip: $server_ip, tailscale_ip: $tailscale_ip, used_snapshot: $used_snapshot}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent success callback with VM metadata for job ${{ inputs.job_id }}"

      - name: Cleanup orphaned VM on failure
        if: failure() && steps.provision.outputs.server_id != ''
        env:
          HETZNER_API_TOKEN: ${{ secrets.HETZNER_API_TOKEN }}
        run: |
          echo "Attempting to delete orphaned Hetzner server ${{ steps.provision.outputs.server_id }}"
          SERVER_ID="${{ steps.provision.outputs.server_id }}"

          # Delete Hetzner server (idempotent - 404 is OK)
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -X DELETE "https://api.hetzner.cloud/v1/servers/${SERVER_ID}" \
            -H "Authorization: Bearer ${HETZNER_API_TOKEN}")

          if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "404" ]; then
            echo "Hetzner server ${SERVER_ID} cleanup successful (HTTP ${HTTP_STATUS})"
          else
            echo "WARNING: Hetzner server ${SERVER_ID} cleanup returned HTTP ${HTTP_STATUS}"
          fi

      - name: Send failure callback
        if: failure()
        run: |
          FAILED_STEP="unknown"
          if [ "${{ steps.provision.outcome }}" = "failure" ]; then
            FAILED_STEP="provision"
          elif [ "${{ steps.configure_snapshot.outcome }}" = "failure" ]; then
            FAILED_STEP="configure_snapshot"
          elif [ "${{ steps.configure_full.outcome }}" = "failure" ]; then
            FAILED_STEP="configure_full"
          fi
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "failed" \
            --arg error "Provisioning workflow failed at $FAILED_STEP" \
            --arg failed_step "$FAILED_STEP" \
            --arg step "$FAILED_STEP" \
            --arg server_id "${{ steps.provision.outputs.server_id }}" \
            --arg server_ip "${{ steps.provision.outputs.server_ip }}" \
            --arg tailscale_ip "${{ steps.provision.outputs.tailscale_ip }}" \
            --arg used_snapshot "${{ steps.provision.outputs.used_snapshot }}" \
            '{job_id: $job_id, status: $status, error: $error, failed_step: $failed_step, step: $step, server_id: $server_id, server_ip: $server_ip, tailscale_ip: $tailscale_ip, used_snapshot: $used_snapshot}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GH_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent failure callback for job ${{ inputs.job_id }}"
