---
phase: 10-status-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/provisioning/queue.ts
  - src/lib/provisioning/index.ts
  - src/app/api/webhooks/github/route.ts
  - src/app/api/agents/[id]/instance/route.ts
autonomous: true

must_haves:
  truths:
    - "Callback handler stores granular step progress when workflow sends step field"
    - "API endpoint returns step-aware provisioning progress to dashboard"
    - "getProvisioningSteps derives UI step states from real currentStep data instead of hard-coded mapping"
    - "Database schema supports currentStep field on agentInstances"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "currentStep column on agentInstances table"
      contains: "currentStep"
    - path: "src/lib/provisioning/queue.ts"
      provides: "updateProvisioningStep function for step progress storage"
      exports: ["updateProvisioningStep"]
    - path: "src/lib/provisioning/index.ts"
      provides: "Dynamic step derivation from currentStep field"
      contains: "currentStep"
    - path: "src/app/api/webhooks/github/route.ts"
      provides: "Step field handling in callback payload"
      contains: "payload.step"
    - path: "src/app/api/agents/[id]/instance/route.ts"
      provides: "currentStep passed to getProvisioningSteps"
      contains: "currentStep"
  key_links:
    - from: "src/app/api/webhooks/github/route.ts"
      to: "src/lib/provisioning/queue.ts"
      via: "updateProvisioningStep call when step field present"
      pattern: "updateProvisioningStep"
    - from: "src/app/api/agents/[id]/instance/route.ts"
      to: "src/lib/provisioning/index.ts"
      via: "getProvisioningSteps receives currentStep from instance"
      pattern: "getProvisioningSteps.*currentStep"
    - from: "src/lib/provisioning/queue.ts"
      to: "src/lib/db/schema.ts"
      via: "updateProvisioningStep writes currentStep to agentInstances"
      pattern: "agentInstances.*currentStep"
---

<objective>
Wire the backend to receive, store, and serve granular provisioning step progress. Add a `currentStep` field to the `agentInstances` table, extend the GitHub callback handler to store step updates, refactor `getProvisioningSteps()` to derive UI step states from real data, and update the instance API endpoint to pass step context.

Purpose: Replace the hard-coded mid-point status mapping with real step-by-step progress so the dashboard shows which provisioning stage is actually happening.

Output: Backend fully capable of receiving step callbacks and serving granular step data to the frontend. Frontend already polls this endpoint and renders steps -- it will display real progress without changes.
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-status-integration/10-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/provisioning/index.ts
@src/lib/provisioning/queue.ts
@src/app/api/webhooks/github/route.ts
@src/app/api/agents/[id]/instance/route.ts
@src/components/dashboard/provisioning-status.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add currentStep to schema and create updateProvisioningStep function</name>
  <files>
    src/lib/db/schema.ts
    src/lib/provisioning/queue.ts
  </files>
  <action>
1. In `src/lib/db/schema.ts`, add a `currentStep` column to the `agentInstances` table definition:
   - `currentStep: text("current_step")` -- nullable text field, placed after the `error` column
   - This stores workflow step identifiers: "vm_created", "network_configured", "ansible_started", "ansible_complete"
   - No index needed (queries are by agentId, not currentStep)

2. Run `npx drizzle-kit generate` to generate the migration for the new column, then run `npx drizzle-kit push` to apply it.

3. In `src/lib/provisioning/queue.ts`, add a new exported function `updateProvisioningStep`:

```typescript
export async function updateProvisioningStep(params: {
  jobId: string;
  step: string;
  metadata?: Record<string, unknown>;
}): Promise<void> {
  const { jobId, step } = params;

  // Get the job to find agentId
  const [job] = await db
    .select()
    .from(provisioningJobs)
    .where(eq(provisioningJobs.id, jobId))
    .limit(1);

  if (!job) {
    console.warn(`[Queue] updateProvisioningStep: job not found: ${jobId}`);
    return;
  }

  // Find the most recent non-terminal instance for this agent
  const instance = await db.query.agentInstances.findFirst({
    where: and(
      eq(agentInstances.agentId, job.agentId),
      inArray(agentInstances.status, ["pending", "provisioning"])
    ),
    orderBy: [desc(agentInstances.createdAt)],
  });

  if (!instance) {
    console.warn(`[Queue] updateProvisioningStep: no active instance for agent ${job.agentId}`);
    return;
  }

  await db
    .update(agentInstances)
    .set({
      currentStep: step,
      updatedAt: new Date(),
    })
    .where(eq(agentInstances.id, instance.id));

  console.log(`[Queue] Updated instance ${instance.id} step: ${step}`);
}
```

Notes:
- Use `warn` instead of throwing when job/instance not found -- step updates are best-effort, should not crash the callback handler
- Query for non-terminal instances (pending, provisioning) to find the right instance
- Do NOT store step metadata in a separate column -- keep it simple with just the step identifier string
  </action>
  <verify>
    - `npx drizzle-kit generate` succeeds and creates a migration SQL file with `ALTER TABLE agent_instances ADD COLUMN current_step TEXT`
    - `npx drizzle-kit push` succeeds
    - `grep -n "currentStep" src/lib/db/schema.ts` shows the new column
    - `grep -n "updateProvisioningStep" src/lib/provisioning/queue.ts` shows the new function
    - `npm run build` compiles without errors
  </verify>
  <done>
    agentInstances table has currentStep column in schema and database. updateProvisioningStep function exists in queue.ts and can update instance step field by job ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend callback handler, refactor getProvisioningSteps, and update instance API</name>
  <files>
    src/app/api/webhooks/github/route.ts
    src/lib/provisioning/index.ts
    src/app/api/agents/[id]/instance/route.ts
  </files>
  <action>
1. In `src/app/api/webhooks/github/route.ts`:
   - Add `step?: string` to the payload type definition (alongside existing `status`, `type`, etc.)
   - Add step handling BEFORE the existing status processing block: when `payload.status === "provisioning" && payload.step`, call `updateProvisioningStep({ jobId: payload.job_id, step: payload.step })` and return early with `{ received: true }`
   - Import `updateProvisioningStep` from `@/lib/provisioning/queue`
   - The existing provisioning status update (without step) continues to work as before for backward compatibility

The logic flow should be:
```
if (heartbeat) → recordHeartbeat
else if (status === "provisioning" && step) → updateProvisioningStep (NEW)
else if (status === "running" + metadata) → completeProvisioningWithMetadata
else if (status) → updateJobStatus + rollback on failure
```

2. In `src/lib/provisioning/index.ts`, refactor `getProvisioningSteps()`:
   - Change signature to accept optional `currentStep` parameter: `getProvisioningSteps(status: ProvisioningStatus["status"], currentStep?: string | null)`
   - Add `currentStep` to the `ProvisioningStatus` type: `currentStep: string | null;`
   - Define step mapping from workflow identifiers to UI step indices:
     ```
     vm_created → index 1 (Creating Server complete)
     network_configured → index 2 (Configuring Network... wait, the current UI has different labels)
     ```

   IMPORTANT: The current UI steps are: Queued (0), Creating Server (1), Installing Dependencies (2), Configuring Agent (3), Running (4).

   Map workflow steps to these existing UI steps:
   - `vm_created` → Creating Server (1) is COMPLETE, Installing Dependencies (2) is ACTIVE
   - `network_configured` → still in Installing Dependencies (2) is ACTIVE (networking is part of VM setup, not a separate UI step)
   - `ansible_started` → Installing Dependencies (2) is COMPLETE, Configuring Agent (3) is ACTIVE
   - `ansible_complete` → Configuring Agent (3) is COMPLETE, Running (4) is ACTIVE (momentarily, before status=running callback)

   The mapping object:
   ```typescript
   const stepToCompletedIndex: Record<string, number> = {
     vm_created: 2,          // steps 0,1 completed, step 2 active
     network_configured: 2,  // same -- networking is sub-step of infra setup
     ansible_started: 3,     // steps 0,1,2 completed, step 3 active
     ansible_complete: 4,    // steps 0,1,2,3 completed, step 4 active
   };
   ```

   For `status === "provisioning"`:
   - If `currentStep` exists and is in the mapping: mark steps below the index as "completed", the step at the index as "active", rest as "pending"
   - If `currentStep` is null (initial provisioning callback): keep existing behavior (step 0 completed, step 1 active -- we know provisioning has started)

   For `status === "failed"`:
   - If `currentStep` exists: mark the step at the mapped index as "error", steps before as "completed"
   - If no `currentStep`: fallback to existing behavior (error at step 2)

   For `status === "running"`: all steps completed (existing behavior)
   For `status === "pending"`: step 0 active (existing behavior)

3. In `src/app/api/agents/[id]/instance/route.ts`:
   - Pass `instance.currentStep` as second argument to `getProvisioningSteps`: `getProvisioningSteps(instance.status, instance.currentStep)`
   - The ProvisioningStatus type now includes `currentStep`, so this should type-check

4. Also in `src/lib/provisioning/index.ts`, update `completeProvisioningWithMetadata` in `queue.ts` to clear `currentStep` when setting status to "running":
   - In the `if (existing)` branch of `completeProvisioningWithMetadata`, add `currentStep: null` to the `.set()` call
   - This ensures terminal states don't carry stale step data
  </action>
  <verify>
    - `npm run build` compiles without TypeScript errors
    - `grep -n "payload.step" src/app/api/webhooks/github/route.ts` shows step handling
    - `grep -n "currentStep" src/lib/provisioning/index.ts` shows step parameter in getProvisioningSteps
    - `grep -n "currentStep" src/app/api/agents/\[id\]/instance/route.ts` shows currentStep passed to getProvisioningSteps
    - `grep -n "currentStep: null" src/lib/provisioning/queue.ts` shows currentStep cleared on completion
  </verify>
  <done>
    Callback handler processes step updates from workflow. getProvisioningSteps uses real currentStep to derive UI step states. Instance API passes currentStep to step derivation. Step state is cleared on terminal status transitions.
  </done>
</task>

</tasks>

<verification>
1. Backend pipeline test: Simulate a callback with `{"job_id":"test","status":"provisioning","step":"vm_created"}` -- verify callback handler calls updateProvisioningStep
2. Step derivation test: Call `getProvisioningSteps("provisioning", "vm_created")` -- verify steps 0,1 are "completed", step 2 is "active", steps 3,4 are "pending"
3. Step derivation test: Call `getProvisioningSteps("provisioning", "ansible_started")` -- verify steps 0,1,2 are "completed", step 3 is "active", step 4 is "pending"
4. Step derivation test: Call `getProvisioningSteps("provisioning", null)` -- verify step 0 is "completed", step 1 is "active" (backward compatible)
5. Step derivation test: Call `getProvisioningSteps("running")` -- verify all steps "completed"
6. Build: `npm run build` passes
</verification>

<success_criteria>
- Database has `current_step` column on `agent_instances` table
- Callback handler stores step progress when step field is present in payload
- getProvisioningSteps returns accurate step states based on real currentStep data
- API endpoint passes currentStep to step derivation function
- Existing provisioning status UI renders real step progress without any component changes
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-status-integration/10-01-SUMMARY.md`
</output>
