---
phase: 10-status-integration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - .github/workflows/provision-agent.yml
autonomous: true

must_haves:
  truths:
    - "Workflow sends granular step callbacks after each major milestone"
    - "Dashboard shows real-time progress through all 5 provisioning steps during workflow execution"
    - "Step callbacks are fire-and-forget (workflow does not fail if callback endpoint is temporarily down)"
    - "Failure callback includes the step where failure occurred"
  artifacts:
    - path: ".github/workflows/provision-agent.yml"
      provides: "Granular step callbacks after VM creation, Ansible start, and Ansible completion"
      contains: "step"
  key_links:
    - from: ".github/workflows/provision-agent.yml"
      to: "src/app/api/webhooks/github/route.ts"
      via: "HTTP POST with step field in JSON body"
      pattern: '"step":"vm_created"'
    - from: ".github/workflows/provision-agent.yml"
      to: "src/app/api/webhooks/github/route.ts"
      via: "HTTP POST with step field in JSON body"
      pattern: '"step":"ansible_started"'
---

<objective>
Add granular step callbacks to the GitHub Actions provisioning workflow so the backend receives real-time progress updates as each major milestone completes. This is the data source that drives the dashboard's step-by-step progress display.

Purpose: The backend (Plan 01) can now receive and store step data. This plan makes the workflow actually send that data at the right moments, completing the full pipeline from workflow execution to dashboard display.

Output: Updated provision-agent.yml with step callback steps after VM provisioning and before/after Ansible configuration.
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-status-integration/10-RESEARCH.md
@.planning/phases/10-status-integration/10-01-PLAN.md
@.github/workflows/provision-agent.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add granular step callbacks to provisioning workflow</name>
  <files>
    .github/workflows/provision-agent.yml
  </files>
  <action>
Add THREE new step callback steps to `.github/workflows/provision-agent.yml`. Each uses the same HMAC signing pattern already established in the workflow. All callbacks use `|| true` to make them fire-and-forget (non-blocking on callback failure).

**Step callback 1: vm_created** -- Insert AFTER the "Provision VM" step, BEFORE "Install Ansible":
```yaml
      - name: Send VM created callback
        if: steps.provision.outcome == 'success'
        run: |
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "vm_created" \
            '{job_id: $job_id, status: $status, step: $step}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent vm_created step callback for job ${{ inputs.job_id }}"
```

**Step callback 2: ansible_started** -- Insert AFTER "Generate Ansible inventory", BEFORE "Configure VM with Ansible":
```yaml
      - name: Send Ansible started callback
        run: |
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "ansible_started" \
            '{job_id: $job_id, status: $status, step: $step}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent ansible_started step callback for job ${{ inputs.job_id }}"
```

**Step callback 3: ansible_complete** -- Insert AFTER "Configure VM with Ansible", BEFORE "Stop heartbeat":
```yaml
      - name: Send Ansible complete callback
        if: steps.configure.outcome == 'success'
        run: |
          BODY=$(jq -n \
            --arg job_id "${{ inputs.job_id }}" \
            --arg status "provisioning" \
            --arg step "ansible_complete" \
            '{job_id: $job_id, status: $status, step: $step}')
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY" || true

          echo "Sent ansible_complete step callback for job ${{ inputs.job_id }}"
```

**Design decisions:**
- Use `jq -n` for JSON construction (matches existing callback pattern in this workflow, per Phase 07 decision)
- Use `|| true` on all step callbacks so they are non-blocking. If the callback endpoint is temporarily down, the workflow continues. The next callback or final success/failure callback will catch up.
- The existing "Send provisioning callback" step (initial status=provisioning, no step field) stays as-is. It triggers the backend to set status=provisioning without a step, which makes the UI show step 0 (Queued) complete and step 1 (Creating Server) active. This is correct -- at that point, the VM hasn't been created yet.
- No `network_configured` callback needed -- Tailscale setup happens inside the `provision-vm.ts` script during "Provision VM" step. The vm_created callback fires after both server creation AND Tailscale enrollment are done, so the UI correctly shows Creating Server as complete.
- The `if:` conditions ensure step callbacks only fire on success. ansible_started has no condition because if we reach that step, everything before succeeded (GitHub Actions runs steps sequentially).

**Also update the failure callback:** The existing failure callback already includes `failed_step` with value "provision" or "configure". Also add the `step` field to the failure payload so the callback handler can update currentStep for proper error display:
- In the "Send failure callback" step, add `--arg step "$FAILED_STEP"` and include `step: $step` in the jq output
- This ensures the callback handler stores which step failed, and getProvisioningSteps can show the error on the right UI step
  </action>
  <verify>
    - `grep -c 'step' .github/workflows/provision-agent.yml` shows multiple occurrences of step callbacks
    - `grep 'vm_created' .github/workflows/provision-agent.yml` shows the VM created callback
    - `grep 'ansible_started' .github/workflows/provision-agent.yml` shows the Ansible started callback
    - `grep 'ansible_complete' .github/workflows/provision-agent.yml` shows the Ansible complete callback
    - The workflow YAML is valid (no syntax errors) -- verify with `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/provision-agent.yml'))"`
    - `npm run build` passes (workflow changes don't affect build, but verify nothing else broke)
  </verify>
  <done>
    Workflow sends 3 granular step callbacks (vm_created, ansible_started, ansible_complete) during provisioning. Failure callback includes step identifier for error display. All step callbacks are fire-and-forget. Existing callback flow (initial provisioning, heartbeat, success, failure) remains unchanged.
  </done>
</task>

</tasks>

<verification>
1. Workflow YAML is valid: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/provision-agent.yml'))"`
2. Full callback sequence during successful provisioning: provisioning (no step) -> vm_created -> ansible_started -> ansible_complete -> running (with metadata)
3. Full callback sequence during failure at Ansible: provisioning (no step) -> vm_created -> ansible_started -> failed (with step=configure)
4. All step callbacks use || true (fire-and-forget)
5. All step callbacks use HMAC signing (same pattern as existing callbacks)
6. UI step progression (when combined with Plan 01 backend):
   - Job queued: Queued=active
   - provisioning callback: Queued=complete, Creating Server=active
   - vm_created callback: Creating Server=complete, Installing Dependencies=active
   - ansible_started callback: Installing Dependencies=complete, Configuring Agent=active
   - ansible_complete callback: Configuring Agent=complete, Running=active
   - running callback: Running=complete (all steps done)
</verification>

<success_criteria>
- Workflow sends vm_created step callback after successful VM provisioning
- Workflow sends ansible_started step callback before Ansible playbook runs
- Workflow sends ansible_complete step callback after Ansible playbook succeeds
- Failure callback includes step identifier for error display
- All step callbacks are fire-and-forget (non-blocking)
- Workflow YAML is valid
- Combined with Plan 01: dashboard shows real-time 5-step progress during provisioning
</success_criteria>

<output>
After completion, create `.planning/phases/10-status-integration/10-02-SUMMARY.md`
</output>
