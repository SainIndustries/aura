---
phase: 09-lifecycle-management
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/app/api/agents/[id]/start/route.ts
  - src/app/api/agents/[id]/stop/route.ts
  - src/app/api/agents/[id]/destroy/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/api/webhooks/github/route.ts
autonomous: true

must_haves:
  truths:
    - "User can stop a running agent via POST /api/agents/{id}/stop which triggers real Hetzner VM shutdown"
    - "User can restart a stopped agent via POST /api/agents/{id}/start which triggers real Hetzner VM power on"
    - "System destroys VM and cleans Tailscale when Stripe subscription.deleted event fires"
    - "System suspends agent (stops VM, preserves data) when Stripe invoice.payment_failed event fires"
    - "GitHub callback handler accepts lifecycle status updates and invokes rollback on provision failure"
  artifacts:
    - path: "src/app/api/agents/[id]/stop/route.ts"
      provides: "Real VM shutdown via lifecycle orchestrator"
      contains: "stopAgent"
    - path: "src/app/api/agents/[id]/start/route.ts"
      provides: "Real VM power-on via lifecycle orchestrator"
      contains: "startAgent"
    - path: "src/app/api/agents/[id]/destroy/route.ts"
      provides: "Agent destruction endpoint"
      exports: ["POST"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Subscription cancellation and payment failure handlers"
      contains: "customer.subscription.deleted"
    - path: "src/app/api/webhooks/github/route.ts"
      provides: "Lifecycle callback handling and rollback trigger"
      contains: "rollbackFailedProvision"
  key_links:
    - from: "src/app/api/agents/[id]/stop/route.ts"
      to: "src/lib/provisioning/lifecycle.ts"
      via: "import stopAgent"
      pattern: "import.*stopAgent.*lifecycle"
    - from: "src/app/api/agents/[id]/start/route.ts"
      to: "src/lib/provisioning/lifecycle.ts"
      via: "import startAgent"
      pattern: "import.*startAgent.*lifecycle"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/provisioning/lifecycle.ts"
      via: "import destroyAgent, stopAgent for subscription events"
      pattern: "import.*destroyAgent.*lifecycle"
    - from: "src/app/api/webhooks/github/route.ts"
      to: "src/lib/provisioning/lifecycle.ts"
      via: "import rollbackFailedProvision for failure handling"
      pattern: "import.*rollbackFailedProvision.*lifecycle"
---

<objective>
Wire lifecycle orchestrator functions into API routes, Stripe webhooks, and GitHub callback handler to enable user-facing stop/start/destroy and system-driven subscription lifecycle management.

Purpose: Connects the core lifecycle logic (Plan 01) to user actions (dashboard API) and system events (Stripe webhooks, provision failure callbacks).
Output: Updated API routes with real VM operations, Stripe webhook handlers for subscription lifecycle, and GitHub callback rollback integration
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-lifecycle-management/09-RESEARCH.md
@.planning/phases/09-lifecycle-management/09-01-SUMMARY.md
@src/app/api/agents/[id]/start/route.ts
@src/app/api/agents/[id]/stop/route.ts
@src/app/api/webhooks/stripe/route.ts
@src/app/api/webhooks/github/route.ts
@src/lib/provisioning/lifecycle.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update start/stop API routes and create destroy route</name>
  <files>src/app/api/agents/[id]/start/route.ts, src/app/api/agents/[id]/stop/route.ts, src/app/api/agents/[id]/destroy/route.ts</files>
  <action>
**Rewrite `src/app/api/agents/[id]/stop/route.ts`:**

The existing stop route only updates the agent status field in the database. Replace it with real VM shutdown logic:

- Keep existing imports (NextRequest, NextResponse, db, agents, auditLogs, eq, and, getCurrentUser)
- Add import: `import { stopAgent } from "@/lib/provisioning/lifecycle";`
- Add import: `import { agentInstances } from "@/lib/db/schema";`
- Keep auth check and agent ownership verification
- Change the status check: if agent.status is NOT "active", return 400 "Agent is not running" (was checking for "paused" before)
- Before calling stopAgent, check if agent has a running instance with a serverId. Query: `db.query.agentInstances.findFirst({ where: and(eq(agentInstances.agentId, id), eq(agentInstances.status, "running")) })`. If instance exists and has serverId, call `await stopAgent(id)` which handles the full Hetzner shutdown + DB updates. If no instance with serverId (simulated/legacy agent), fall back to the original behavior: just update agent status to "paused" in DB.
- Keep the audit log insert (action: "agent_stopped")
- Return success response with updated agent status

**Rewrite `src/app/api/agents/[id]/start/route.ts`:**

The existing start route only updates agent status. Replace with real VM power-on logic:

- Keep existing imports, add: `import { startAgent } from "@/lib/provisioning/lifecycle";`
- Add import: `import { agentInstances } from "@/lib/db/schema";`
- Keep auth check and agent ownership verification
- Change the status check: if agent.status is NOT "paused", return 400 "Agent is not paused" (was checking for "active" before)
- Before calling startAgent, check if agent has a stopped instance with serverId. If instance exists and has serverId, call `await startAgent(id)`. If no instance with serverId, fall back to original behavior: just update agent status to "active" in DB.
- Keep audit log (action: "agent_started")
- Return success response

**Create `src/app/api/agents/[id]/destroy/route.ts`:**

New route for agent destruction (used by subscription cancellation webhook and potentially admin tools):

- Import: NextRequest, NextResponse, db, agents, auditLogs, agentInstances, eq, and, getCurrentUser, destroyAgent from lifecycle
- Auth check + agent ownership verification
- Check agent has an instance (any status) with serverId
- If instance with serverId exists: call `await destroyAgent(id)` (handles Hetzner delete + Tailscale cleanup + DB updates)
- If no infrastructure instance: just update agent status to "paused" and instance status to "stopped"
- Audit log: action "agent_destroyed", description includes agent name
- Return success response

Error handling for all three routes: wrap lifecycle calls in try/catch. On error, return 500 with `{ error: "Failed to {action} agent", details: error.message }`. Log the full error.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify imports: `grep "stopAgent\|startAgent\|destroyAgent" src/app/api/agents/\[id\]/*/route.ts` should show lifecycle imports in all three routes.</verify>
  <done>Stop/start API routes call real Hetzner shutdown/poweron via lifecycle orchestrator. Destroy route exists for full cleanup. All routes have backward compatibility for agents without infrastructure (simulated/legacy).</done>
</task>

<task type="auto">
  <name>Task 2: Add subscription lifecycle handlers to Stripe webhook and rollback to GitHub callback</name>
  <files>src/app/api/webhooks/stripe/route.ts, src/app/api/webhooks/github/route.ts</files>
  <action>
**In `src/app/api/webhooks/stripe/route.ts`:**

Add imports at top: `import { destroyAgent, stopAgent } from "@/lib/provisioning/lifecycle";` and `import { agentInstances } from "@/lib/db/schema";`

Add two new cases in the switch statement:

1. **`case "customer.subscription.deleted":`** (LIFE-03)
   - This case already exists but only calls `upsertSubscription`. Add lifecycle logic AFTER the upsertSubscription call:
   - Extract `sub.customer` to get customerId (string or object, extract .id)
   - Look up user by stripeCustomerId: `db.query.users.findFirst({ where: eq(users.stripeCustomerId, customerId) })`
   - If no user found, log warning and break
   - Find all agents with running instances for this user:
     ```
     const userAgents = await db.query.agents.findMany({
       where: eq(agents.userId, user.id),
       with: { instances: true },
     });
     ```
   - For each agent that has an instance with status "running" and a serverId:
     - Wrap in try/catch: call `await destroyAgent(agent.id)`
     - Log: `[Stripe Webhook] Destroyed agent ${agent.id} due to subscription cancellation`
     - On error, log but continue to next agent
   - Keep existing `upsertSubscription(sub)` call (it's already there in the combined case)
   - IMPORTANT: Split the existing combined case `case "customer.subscription.updated": case "customer.subscription.deleted":` into separate cases. `customer.subscription.updated` keeps only `upsertSubscription`. `customer.subscription.deleted` gets `upsertSubscription` PLUS the destroy logic above.

2. **Modify `case "invoice.payment_failed":`** (LIFE-05)
   - This case already exists but only calls `upsertSubscription`. Add suspension logic AFTER the upsertSubscription call:
   - Extract customerId from invoice.customer (same pattern as above)
   - Look up user by stripeCustomerId
   - If no user found, log warning and break
   - Find all agents with running instances (same query pattern as above)
   - For each agent that has a running instance with serverId:
     - Wrap in try/catch: call `await stopAgent(agent.id)` (stops VM but preserves data)
     - Log: `[Stripe Webhook] Suspended agent ${agent.id} due to payment failure`
     - On error, log but continue
   - Keep existing `upsertSubscription(sub)` call

**In `src/app/api/webhooks/github/route.ts`:**

Add import: `import { rollbackFailedProvision } from "@/lib/provisioning/lifecycle";`

Modify the `status === "failed"` handling block. Currently it just calls `updateJobStatus`. After the existing `updateJobStatus` call for failed status, add rollback:

```typescript
// After updateJobStatus for failed status:
// Trigger rollback to clean up orphaned resources
try {
  await rollbackFailedProvision(payload.job_id);
  console.log(`[GitHub Callback] Rollback completed for failed job ${payload.job_id}`);
} catch (rollbackError) {
  console.error(`[GitHub Callback] Rollback failed for job ${payload.job_id}:`, rollbackError);
  // Log but don't fail the callback response - rollback is best-effort
}
```

This integrates the rollback so that when the provision workflow fails and sends a failure callback, the system automatically cleans up any orphaned Hetzner VMs and Tailscale devices.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify Stripe webhook has separate cases: `grep -c "customer.subscription.deleted\|invoice.payment_failed" src/app/api/webhooks/stripe/route.ts` should return at least 2. Verify GitHub callback imports rollback: `grep "rollbackFailedProvision" src/app/api/webhooks/github/route.ts`.</verify>
  <done>Stripe webhook handles subscription.deleted (destroys VM + Tailscale cleanup) and invoice.payment_failed (suspends agent, preserves data) separately. GitHub callback triggers automatic rollback on provision failure. All operations are wrapped in try/catch for resilience.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Stop route imports and calls stopAgent from lifecycle module
3. Start route imports and calls startAgent from lifecycle module
4. Destroy route exists and calls destroyAgent
5. Stripe webhook has separate handler for customer.subscription.deleted that calls destroyAgent
6. Stripe webhook handles invoice.payment_failed by calling stopAgent (suspend, not destroy)
7. GitHub callback handler triggers rollbackFailedProvision on status=failed
8. All routes maintain backward compatibility for agents without infrastructure
</verification>

<success_criteria>
User-facing stop/start/destroy operations trigger real Hetzner API calls via lifecycle orchestrator. System automatically destroys VMs on subscription cancellation and suspends agents on payment failure. Failed provisions trigger automatic rollback of orphaned resources.
</success_criteria>

<output>
After completion, create `.planning/phases/09-lifecycle-management/09-02-SUMMARY.md`
</output>
