---
phase: 09-lifecycle-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/hetzner.ts
  - src/lib/tailscale.ts
  - src/lib/provisioning/lifecycle.ts
autonomous: true

must_haves:
  truths:
    - "Hetzner server can be gracefully shut down with timeout fallback to forced poweroff"
    - "Hetzner server can be powered on from stopped state"
    - "Tailscale device can be deleted from network (idempotent, 404 treated as success)"
    - "Tailscale devices can be listed to find device by IP"
    - "Agent lifecycle orchestrator can stop, start, and destroy agents with proper state transitions"
    - "Rollback function can clean up orphaned Hetzner VMs and Tailscale devices after provision failure"
  artifacts:
    - path: "src/lib/hetzner.ts"
      provides: "shutdownServer, powerOnServer, powerOffServer functions"
      contains: "shutdownServer"
    - path: "src/lib/tailscale.ts"
      provides: "listDevices, deleteDevice, findDeviceByIp functions"
      contains: "deleteDevice"
    - path: "src/lib/provisioning/lifecycle.ts"
      provides: "stopAgent, startAgent, destroyAgent, rollbackFailedProvision orchestrators"
      exports: ["stopAgent", "startAgent", "destroyAgent", "rollbackFailedProvision"]
  key_links:
    - from: "src/lib/provisioning/lifecycle.ts"
      to: "src/lib/hetzner.ts"
      via: "import shutdownServer, powerOnServer, deleteServer"
      pattern: "import.*from.*hetzner"
    - from: "src/lib/provisioning/lifecycle.ts"
      to: "src/lib/tailscale.ts"
      via: "import deleteDevice, findDeviceByIp"
      pattern: "import.*from.*tailscale"
    - from: "src/lib/provisioning/lifecycle.ts"
      to: "src/lib/db/schema"
      via: "import agentInstances, agents for state transitions"
      pattern: "import.*agentInstances.*agents"
---

<objective>
Add VM power management to Hetzner client, device cleanup to Tailscale client, and create the lifecycle orchestrator module that coordinates stop/start/destroy/rollback operations.

Purpose: Provides the core backend logic for all lifecycle operations. API routes, workflows, and webhooks (Plan 02/03) will call these functions.
Output: Extended hetzner.ts and tailscale.ts modules + new lifecycle.ts orchestrator
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-lifecycle-management/09-RESEARCH.md
@src/lib/hetzner.ts
@src/lib/tailscale.ts
@src/lib/provisioning/queue.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add power management functions to Hetzner and device management to Tailscale</name>
  <files>src/lib/hetzner.ts, src/lib/tailscale.ts</files>
  <action>
**In src/lib/hetzner.ts**, add three new exported functions after the existing `deleteServer` function:

1. `shutdownServer(serverId: number): Promise<void>` - Graceful ACPI shutdown via POST `/servers/{serverId}/actions/shutdown`. Uses `fetchWithRateLimit`. Calls `waitForAction` with 60 retries at 1s interval (60s timeout). On timeout, falls back to `powerOffServer`. Log: `[Hetzner] Server ${serverId} shut down gracefully` on success, warn on fallback.

2. `powerOnServer(serverId: number): Promise<void>` - Power on via POST `/servers/{serverId}/actions/poweron`. Uses `fetchWithRateLimit`. Calls `waitForAction` with default options. Log: `[Hetzner] Server ${serverId} powered on`.

3. `powerOffServer(serverId: number): Promise<void>` - Forceful power off via POST `/servers/{serverId}/actions/poweroff`. Uses `fetchWithRateLimit`. Calls `waitForAction` with default options. Log: `[Hetzner] Server ${serverId} forced power off`. Add JSDoc warning that this may cause data loss.

All three follow the same pattern as existing `createServer`/`deleteServer`: get token from `getHetznerConfig()`, construct URL, POST with Bearer auth, check response.ok, parse action from response, wait for action completion.

Also update `deleteServer` to be idempotent: if response.status is 404, treat as success (log and return) instead of throwing. This is critical for rollback scenarios.

**In src/lib/tailscale.ts**, add three new exported functions:

1. `listDevices(): Promise<TailscaleDevice[]>` - GET `https://api.tailscale.com/api/v2/tailnet/-/devices`. Uses `getOAuthToken()` for Bearer auth. Returns `data.devices`. The `TailscaleDevice` interface already exists in this file.

2. `deleteDevice(deviceId: string): Promise<void>` - DELETE `https://api.tailscale.com/api/v2/device/${deviceId}`. Uses `getOAuthToken()` for Bearer auth. Idempotent: 404 is treated as success (log and return, do not throw). Log: `[Tailscale] Device ${deviceId} deleted from network`.

3. `findDeviceByIp(tailscaleIp: string): Promise<TailscaleDevice | undefined>` - Calls `listDevices()`, returns `devices.find(d => d.addresses.includes(tailscaleIp))`. Simple helper for rollback/cleanup.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify exports: `grep -c "export async function" src/lib/hetzner.ts` should be 7 (createServer, waitForAction, deleteServer, fetchWithRateLimit, shutdownServer, powerOnServer, powerOffServer). `grep -c "export async function" src/lib/tailscale.ts` should be 6 (getOAuthToken, createAuthKey, verifyEnrollment, listDevices, deleteDevice, findDeviceByIp).</verify>
  <done>Hetzner client has shutdown/poweron/poweroff functions with graceful-to-forced fallback. Tailscale client has listDevices/deleteDevice/findDeviceByIp with idempotent deletion. deleteServer handles 404 as success.</done>
</task>

<task type="auto">
  <name>Task 2: Create lifecycle orchestrator module</name>
  <files>src/lib/provisioning/lifecycle.ts</files>
  <action>
Create `src/lib/provisioning/lifecycle.ts` with four exported async functions. Import from `../hetzner` (shutdownServer, powerOnServer, deleteServer), `../tailscale` (deleteDevice, findDeviceByIp), `@/lib/db` (db), `@/lib/db/schema` (agentInstances, agents, provisioningJobs), and `drizzle-orm` (eq, and).

Note on imports: Use `@/lib/` path aliases (not relative `../`) for db and schema since this module runs in the Next.js context, not standalone in GitHub Actions like provision-vm.ts does.

1. **`stopAgent(agentId: string): Promise<void>`** (LIFE-01)
   - Query agentInstances for this agent where status = "running"
   - If no running instance, throw `"No running instance to stop"`
   - Update instance status to "stopping"
   - Try: call `shutdownServer(parseInt(instance.serverId!))` (serverId is stored as string)
   - On success: update instance status to "stopped", set stoppedAt = new Date(), update agent status to "paused"
   - On failure: rollback instance status to "running", re-throw error
   - Log: `[Lifecycle] Agent ${agentId} stopped successfully`

2. **`startAgent(agentId: string): Promise<void>`** (LIFE-02)
   - Query agentInstances for this agent where status = "stopped"
   - If no stopped instance, throw `"No stopped instance to start"`
   - Update instance status to "provisioning" (reuse existing enum value for "starting" transitional state)
   - Try: call `powerOnServer(parseInt(instance.serverId!))`
   - On success: update instance status to "running", set startedAt = new Date(), stoppedAt = null, update agent status to "active"
   - On failure: rollback instance status to "stopped", re-throw error
   - Log: `[Lifecycle] Agent ${agentId} started successfully`

3. **`destroyAgent(agentId: string): Promise<void>`** (LIFE-03)
   - Query agentInstances for this agent (any status)
   - If no instance, log and return (nothing to cleanup)
   - Update instance status to "stopping" (transitional)
   - Delete Hetzner server if serverId exists: wrap in try/catch, log errors but continue (idempotent)
   - Delete Tailscale device if tailscaleIp exists: call findDeviceByIp then deleteDevice, wrap in try/catch, log errors but continue (idempotent)
   - Update instance status to "stopped", set error = "Destroyed via lifecycle management"
   - Update agent status to "paused"
   - Log: `[Lifecycle] Agent ${agentId} destroyed successfully`

4. **`rollbackFailedProvision(jobId: string): Promise<void>`** (LIFE-04)
   - Query provisioningJobs by jobId
   - If no job, throw `"Job ${jobId} not found"`
   - Query agentInstances by job.agentId
   - If no instance or no serverId, log "No VM to clean up" and return
   - Track cleanup results: `cleanedHetzner = false`, `cleanedTailscale = false`
   - Try deleteServer(parseInt(instance.serverId)): set cleanedHetzner = true on success, log error on failure
   - If instance.tailscaleIp: try findDeviceByIp then deleteDevice: set cleanedTailscale = true, log error on failure
   - Update instance status to "failed", set error = "Rolled back after provision failure. Cleaned: Hetzner=${cleanedHetzner}, Tailscale=${cleanedTailscale}"
   - Update agent status to "error"
   - Log: `[Lifecycle] Cleanup complete for job ${jobId}`
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify all 4 functions are exported: `grep -c "export async function" src/lib/provisioning/lifecycle.ts` should be 4. Verify imports from hetzner and tailscale are present.</verify>
  <done>Lifecycle orchestrator module exists with stopAgent, startAgent, destroyAgent, and rollbackFailedProvision. Each function handles state transitions atomically with rollback on failure. Cleanup operations are idempotent (404 = success).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Hetzner module exports 7 async functions (4 existing + 3 new)
3. Tailscale module exports 6 async functions (3 existing + 3 new)
4. Lifecycle module exports 4 orchestrator functions
5. All new functions use existing patterns (fetchWithRateLimit, getHetznerConfig, getOAuthToken)
6. deleteServer handles 404 idempotently
7. deleteDevice handles 404 idempotently
</verification>

<success_criteria>
Core lifecycle logic is complete: VMs can be stopped/started/destroyed via Hetzner API, Tailscale devices can be cleaned up, and failed provisions can be rolled back. All operations are idempotent and handle errors gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/09-lifecycle-management/09-01-SUMMARY.md`
</output>
