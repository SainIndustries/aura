---
phase: 07-vm-provisioning-via-hetzner-api
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/lib/provisioning/provision-vm.ts
  - .github/workflows/provision-agent.yml
autonomous: true

must_haves:
  truths:
    - "GitHub Actions workflow executes real VM provisioning when dispatched"
    - "Workflow creates Hetzner VM with cloud-init Tailscale setup"
    - "Workflow polls Hetzner action status and Tailscale enrollment"
    - "Workflow sends VM metadata (server_id, server_ip, tailscale_ip) in success callback"
    - "Workflow handles provisioning failures and sends error details in failure callback"
  artifacts:
    - path: "src/lib/provisioning/provision-vm.ts"
      provides: "VM provisioning orchestrator function"
      exports: ["provisionVM"]
      min_lines: 60
    - path: ".github/workflows/provision-agent.yml"
      provides: "Real provisioning workflow replacing placeholder"
      contains: "npx tsx"
  key_links:
    - from: "src/lib/provisioning/provision-vm.ts"
      to: "src/lib/hetzner.ts"
      via: "imports createServer, waitForAction"
      pattern: "import.*from.*hetzner"
    - from: "src/lib/provisioning/provision-vm.ts"
      to: "src/lib/tailscale.ts"
      via: "imports createAuthKey, verifyEnrollment"
      pattern: "import.*from.*tailscale"
    - from: "src/lib/provisioning/provision-vm.ts"
      to: "src/lib/cloud-init.ts"
      via: "imports generateCloudInitConfig"
      pattern: "import.*from.*cloud-init"
    - from: ".github/workflows/provision-agent.yml"
      to: "src/lib/provisioning/provision-vm.ts"
      via: "npx tsx script execution"
      pattern: "npx tsx"
---

<objective>
Create the VM provisioning orchestrator that ties together Hetzner, Tailscale, and cloud-init modules, then wire it into the GitHub Actions workflow replacing the placeholder provisioning step.

Purpose: This is the core of Phase 7 -- turning the placeholder "Simulating work (5 seconds)" into real infrastructure creation. The orchestrator runs as a Node.js script inside GitHub Actions, creating a Hetzner VM with Tailscale networking.

Output: `src/lib/provisioning/provision-vm.ts` orchestrator + updated `provision-agent.yml` workflow
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-vm-provisioning-via-hetzner-api/07-RESEARCH.md
@.planning/phases/07-vm-provisioning-via-hetzner-api/07-01-SUMMARY.md
@src/lib/hetzner.ts
@src/lib/tailscale.ts
@src/lib/cloud-init.ts
@.github/workflows/provision-agent.yml
@src/lib/provisioning/github-actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VM provisioning orchestrator script</name>
  <files>src/lib/provisioning/provision-vm.ts</files>
  <action>
Create `src/lib/provisioning/provision-vm.ts` that orchestrates the full VM provisioning flow.

**Export interface `ProvisionVMParams`:**
```
{
  jobId: string;
  agentId: string;
  region: string;
}
```

**Export interface `ProvisionVMResult`:**
```
{
  serverId: number;
  serverIp: string;
  tailscaleIp: string;
  serverName: string;
}
```

**Export async function `provisionVM(params: ProvisionVMParams): Promise<ProvisionVMResult>`:**

Orchestration steps (each logged with `[ProvisionVM]` prefix):

1. **Generate server name:** `agent-${agentId.slice(0, 8)}-${Date.now()}` for uniqueness (per research recommendation of agent-${userId}-${timestamp}, but using agentId since that's more relevant)

2. **Map region to Hetzner location:** Create a simple map: `{ "us-east": "ash", "eu-central": "nbg1", "eu-west": "fsn1", "ap-southeast": "sin" }`. Default to "nbg1" if region not in map. Log the mapped location.

3. **Create Tailscale ephemeral auth key:** Call `createAuthKey()` from `@/lib/tailscale`. Log: "Tailscale auth key generated"

4. **Generate cloud-init config:** Call `generateCloudInitConfig({ tailscaleAuthKey: authKey, hostname: serverName })` from `@/lib/cloud-init`. Log: "Cloud-init config generated"

5. **Read SSH key ID from env:** Read `HETZNER_SSH_KEY_ID` from `process.env`. This is the numeric ID of the platform SSH key pre-uploaded to Hetzner. Throw if missing.

6. **Create Hetzner server:** Call `createServer({ name: serverName, serverType: "cpx11", image: "ubuntu-22.04", location: mappedLocation, sshKeys: [parseInt(HETZNER_SSH_KEY_ID)], userData: cloudInitConfig, labels: { provisioning_job_id: jobId, agent_id: agentId } })` from `@/lib/hetzner`. Log: "Hetzner server created: id={serverId}, ip={serverIp}"

7. **Wait for Hetzner action completion:** Call `waitForAction(response.action.id)`. Log: "Hetzner server is ready"

8. **Verify Tailscale enrollment:** Call `verifyEnrollment(serverName)` from `@/lib/tailscale`. This polls until the VM appears on the Tailscale network. Log: "Tailscale enrollment verified: ip={tailscaleIp}"

9. **Return result:** `{ serverId: response.server.id, serverIp: response.server.public_net.ipv4.ip, tailscaleIp: enrollment.tailscaleIp, serverName }`

**Error handling:** Let errors propagate. The caller (workflow script or CLI entry point) handles errors. Each step's log provides debugging context.

**Also create a CLI entry point at the bottom of the file** (guarded by `if (require.main === module)` or equivalent for tsx):

```typescript
// CLI entry point for GitHub Actions
async function main() {
  const jobId = process.env.JOB_ID;
  const agentId = process.env.AGENT_ID;
  const region = process.env.REGION || "us-east";

  if (!jobId || !agentId) {
    console.error("Missing required env vars: JOB_ID, AGENT_ID");
    process.exit(1);
  }

  try {
    const result = await provisionVM({ jobId, agentId, region });
    // Output for GitHub Actions to capture
    console.log(`::set-output name=server_id::${result.serverId}`);
    console.log(`::set-output name=server_ip::${result.serverIp}`);
    console.log(`::set-output name=tailscale_ip::${result.tailscaleIp}`);
    console.log(`::set-output name=server_name::${result.serverName}`);
    // Also write to GITHUB_OUTPUT for modern Actions
    const fs = await import('fs');
    const outputFile = process.env.GITHUB_OUTPUT;
    if (outputFile) {
      fs.appendFileSync(outputFile, `server_id=${result.serverId}\n`);
      fs.appendFileSync(outputFile, `server_ip=${result.serverIp}\n`);
      fs.appendFileSync(outputFile, `tailscale_ip=${result.tailscaleIp}\n`);
      fs.appendFileSync(outputFile, `server_name=${result.serverName}\n`);
    }
  } catch (error) {
    console.error("[ProvisionVM] Fatal error:", error);
    process.exit(1);
  }
}

// Run as CLI when executed directly
const isMainModule = typeof require !== 'undefined' ? require.main === module : process.argv[1]?.includes('provision-vm');
if (isMainModule) {
  main();
}
```

Import paths use `@/lib/...` aliases. Since this runs in GitHub Actions via `npx tsx`, the path aliases must be resolved. The workflow step will use `npx tsx --tsconfig tsconfig.json` to ensure path resolution works, OR the imports can use relative paths (`../hetzner`, `../tailscale`, `../cloud-init`) for reliability in the CLI context. **Use relative imports** for the Hetzner/Tailscale/CloudInit modules since this file runs as a standalone script in GitHub Actions where `@/` aliases may not resolve. Import as: `import { createServer, waitForAction } from "../hetzner"` etc.
  </action>
  <verify>
`npx tsc --noEmit` passes. File exports `provisionVM`, `ProvisionVMParams`, `ProvisionVMResult`. File imports from `../hetzner`, `../tailscale`, `../cloud-init`. File contains `GITHUB_OUTPUT` for modern Actions output. File contains region-to-location mapping with "nbg1" default.
  </verify>
  <done>
`src/lib/provisioning/provision-vm.ts` exports provisionVM orchestrator that creates Hetzner VM with Tailscale networking. Has CLI entry point for GitHub Actions execution with GITHUB_OUTPUT support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace workflow placeholder with real provisioning</name>
  <files>.github/workflows/provision-agent.yml</files>
  <action>
Update `.github/workflows/provision-agent.yml` to replace the "Provision VM (placeholder)" step with real provisioning using the TypeScript orchestrator.

**Keep unchanged:**
- `name: Provision Agent`
- `on: workflow_dispatch` with same 4 inputs (job_id, agent_id, region, callback_url)
- `jobs: provision: runs-on: ubuntu-latest, timeout-minutes: 15`
- `Checkout` step
- `Send provisioning callback` step (status: provisioning)
- `Heartbeat loop` step
- `Stop heartbeat` step

**Add new step after Checkout, before provisioning callback:** "Setup Node.js"
```yaml
- name: Setup Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'

- name: Install dependencies
  run: npm ci
```

This is needed because `npx tsx` requires the project dependencies to resolve TypeScript and path aliases.

**Replace "Provision VM (placeholder)" step with:**
```yaml
- name: Provision VM
  id: provision
  env:
    HETZNER_API_TOKEN: ${{ secrets.HETZNER_API_TOKEN }}
    HETZNER_SSH_KEY_ID: ${{ secrets.HETZNER_SSH_KEY_ID }}
    TAILSCALE_OAUTH_CLIENT_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
    TAILSCALE_OAUTH_CLIENT_SECRET: ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
    JOB_ID: ${{ inputs.job_id }}
    AGENT_ID: ${{ inputs.agent_id }}
    REGION: ${{ inputs.region }}
  run: npx tsx src/lib/provisioning/provision-vm.ts
```

**Update "Send success callback" step to include VM metadata:**
The success callback BODY must now include server_id, server_ip, and tailscale_ip from the provision step outputs:
```yaml
- name: Send success callback
  if: success()
  run: |
    BODY=$(jq -n \
      --arg job_id "${{ inputs.job_id }}" \
      --arg status "running" \
      --arg server_id "${{ steps.provision.outputs.server_id }}" \
      --arg server_ip "${{ steps.provision.outputs.server_ip }}" \
      --arg tailscale_ip "${{ steps.provision.outputs.tailscale_ip }}" \
      '{job_id: $job_id, status: $status, server_id: $server_id, server_ip: $server_ip, tailscale_ip: $tailscale_ip}')
    SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

    curl -sf -X POST "${{ inputs.callback_url }}" \
      -H "Content-Type: application/json" \
      -H "X-Signature: $SIGNATURE" \
      -d "$BODY"

    echo "Sent success callback with VM metadata for job ${{ inputs.job_id }}"
```

Use `jq -n` for JSON construction (available on ubuntu-latest) instead of string interpolation to avoid JSON escaping issues.

**Update "Send failure callback" step** to use `jq` for consistency:
```yaml
- name: Send failure callback
  if: failure()
  run: |
    BODY=$(jq -n \
      --arg job_id "${{ inputs.job_id }}" \
      --arg status "failed" \
      --arg error "Provisioning workflow failed" \
      --arg failed_step "provision" \
      '{job_id: $job_id, status: $status, error: $error, failed_step: $failed_step}')
    SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

    curl -sf -X POST "${{ inputs.callback_url }}" \
      -H "Content-Type: application/json" \
      -H "X-Signature: $SIGNATURE" \
      -d "$BODY"

    echo "Sent failure callback for job ${{ inputs.job_id }}"
```

**Step order in final workflow:**
1. Checkout
2. Setup Node.js
3. Install dependencies
4. Send provisioning callback
5. Heartbeat loop
6. Provision VM (real -- runs provision-vm.ts)
7. Stop heartbeat
8. Send success callback (includes VM metadata)
9. Send failure callback (on failure)

The workflow now creates a real Hetzner VM with Tailscale, rather than sleeping for 5 seconds.
  </action>
  <verify>
File `.github/workflows/provision-agent.yml` contains: `npx tsx src/lib/provisioning/provision-vm.ts`, `HETZNER_API_TOKEN`, `TAILSCALE_OAUTH_CLIENT_ID`, `actions/setup-node@v4`, `npm ci`, `steps.provision.outputs.server_id`, `jq -n`. File does NOT contain "Simulating work" or "placeholder" (case-insensitive). YAML is valid (no syntax errors).
  </verify>
  <done>
`provision-agent.yml` workflow executes real VM provisioning via the TypeScript orchestrator. Success callback includes server_id, server_ip, tailscale_ip. Failure callback sends structured error. Node.js 20 setup and npm ci ensure TypeScript execution works in Actions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero new TypeScript errors
2. `src/lib/provisioning/provision-vm.ts` exists and exports provisionVM
3. `.github/workflows/provision-agent.yml` no longer has placeholder step
4. Workflow sends VM metadata (server_id, server_ip, tailscale_ip) in success callback
5. Workflow uses secrets for all API tokens (HETZNER_API_TOKEN, TAILSCALE_OAUTH_*)
6. Workflow sets up Node.js and installs deps before running TypeScript
</verification>

<success_criteria>
GitHub Actions workflow can execute real VM provisioning when dispatched. The orchestrator creates a Hetzner VM, waits for it to be ready, verifies Tailscale enrollment, and outputs VM metadata. Success callback sends all metadata back to the application.
</success_criteria>

<output>
After completion, create `.planning/phases/07-vm-provisioning-via-hetzner-api/07-02-SUMMARY.md`
</output>
