---
phase: 07-vm-provisioning-via-hetzner-api
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/webhooks/github/route.ts
  - src/lib/provisioning/queue.ts
autonomous: true

must_haves:
  truths:
    - "Callback handler accepts VM metadata (server_id, server_ip, tailscale_ip) in success payload"
    - "VM metadata is stored in agentInstances table when provisioning succeeds"
    - "Agent instance record is created or updated with real infrastructure data"
    - "Provisioning job completion triggers agent instance status update"
  artifacts:
    - path: "src/app/api/webhooks/github/route.ts"
      provides: "Extended callback handler with VM metadata support"
      exports: ["POST"]
      min_lines: 60
    - path: "src/lib/provisioning/queue.ts"
      provides: "Function to store VM metadata and update agent instance"
      exports: ["completeProvisioningWithMetadata"]
      min_lines: 180
  key_links:
    - from: "src/app/api/webhooks/github/route.ts"
      to: "src/lib/provisioning/queue.ts"
      via: "calls completeProvisioningWithMetadata on status=running with metadata"
      pattern: "completeProvisioningWithMetadata"
    - from: "src/lib/provisioning/queue.ts"
      to: "src/lib/db/schema.ts"
      via: "inserts/updates agentInstances table"
      pattern: "agentInstances"
---

<objective>
Extend the GitHub Actions callback handler to accept VM metadata in the success payload and store it in the database, completing the data path from infrastructure creation back to the application.

Purpose: When the workflow sends `{job_id, status: "running", server_id, server_ip, tailscale_ip}`, the callback handler must update the provisioning job AND create/update the agent instance record with real infrastructure data. Without this, the VM is created but the application doesn't know about it.

Output: Extended `route.ts` callback handler + new `completeProvisioningWithMetadata` function in queue module
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-async-pipeline-foundation/06-01-SUMMARY.md
@.planning/phases/06-async-pipeline-foundation/06-03-SUMMARY.md
@src/app/api/webhooks/github/route.ts
@src/lib/provisioning/queue.ts
@src/lib/db/schema.ts
@src/lib/provisioning/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add completeProvisioningWithMetadata to queue module</name>
  <files>src/lib/provisioning/queue.ts</files>
  <action>
Add a new exported function to `src/lib/provisioning/queue.ts` that handles the complete provisioning success path: updating the job to "running" AND creating/updating the agent instance with VM metadata.

**Add imports at top of file:**
- Import `agentInstances` from `@/lib/db/schema` (add to existing import)

**New export interface `VMMetadata`:**
```typescript
export interface VMMetadata {
  serverId: string;    // Hetzner server ID (as string from callback JSON)
  serverIp: string;    // Public IPv4
  tailscaleIp: string; // Tailscale network IP
}
```

**New export function `completeProvisioningWithMetadata(params)`:**
```typescript
export async function completeProvisioningWithMetadata(params: {
  jobId: string;
  metadata: VMMetadata;
}): Promise<void>
```

Implementation:
1. First, get the job to find the agentId: `SELECT * FROM provisioning_jobs WHERE id = jobId`
2. If no job found, throw: "Job not found: ${jobId}"
3. Update job status to "running" via existing `updateJobStatus({ jobId, status: "running" })`
4. Check if agent already has an instance (any non-stopped/non-failed instance):
   ```typescript
   const existing = await db.query.agentInstances.findFirst({
     where: and(
       eq(agentInstances.agentId, job.agentId),
       inArray(agentInstances.status, ["pending", "provisioning", "running"])
     ),
   });
   ```
5. If existing instance: UPDATE it with the VM metadata:
   ```typescript
   await db.update(agentInstances)
     .set({
       status: "running",
       serverId: metadata.serverId,
       serverIp: metadata.serverIp,
       tailscaleIp: metadata.tailscaleIp,
       region: job.region,
       startedAt: new Date(),
       updatedAt: new Date(),
     })
     .where(eq(agentInstances.id, existing.id));
   ```
6. If no existing instance: INSERT a new one:
   ```typescript
   await db.insert(agentInstances).values({
     agentId: job.agentId,
     status: "running",
     serverId: metadata.serverId,
     serverIp: metadata.serverIp,
     tailscaleIp: metadata.tailscaleIp,
     region: job.region,
     startedAt: new Date(),
   });
   ```
7. Log: `[Queue] Provisioning complete for job ${jobId}: server=${metadata.serverId}, ip=${metadata.serverIp}, tailscale=${metadata.tailscaleIp}`

**Also update agent status to "active":**
After creating/updating the instance, update the agent's status to "active":
```typescript
import { agents } from "@/lib/db/schema";
await db.update(agents)
  .set({ status: "active", updatedAt: new Date() })
  .where(eq(agents.id, job.agentId));
```
This is important because the agent was likely in "draft" status before provisioning.

Keep all existing functions unchanged. Only add the new function and imports.
  </action>
  <verify>
`npx tsc --noEmit` passes. `completeProvisioningWithMetadata` is exported from queue.ts. File imports `agentInstances` and `agents` from schema. Function updates both provisioningJobs status and agentInstances with metadata. Function updates agent status to "active".
  </verify>
  <done>
`src/lib/provisioning/queue.ts` exports `completeProvisioningWithMetadata` that atomically updates the provisioning job to "running", creates/updates agent instance with VM metadata (serverId, serverIp, tailscaleIp), and sets agent status to "active".
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend GitHub callback handler for VM metadata</name>
  <files>src/app/api/webhooks/github/route.ts</files>
  <action>
Extend the GitHub Actions callback webhook handler to accept VM metadata in the success payload and route it to the new `completeProvisioningWithMetadata` function.

**Add import:**
```typescript
import { updateJobStatus, recordHeartbeat, completeProvisioningWithMetadata } from "@/lib/provisioning/queue";
```
(Replace the existing import line that only imports `updateJobStatus, recordHeartbeat`)

**Extend the payload type:**
Add optional VM metadata fields to the parsed payload type:
```typescript
let payload: {
  job_id: string;
  status?: "provisioning" | "running" | "failed";
  type?: "heartbeat";
  workflow_run_id?: string;
  error?: string;
  failed_step?: string;
  // VM metadata (sent with status=running)
  server_id?: string;
  server_ip?: string;
  tailscale_ip?: string;
};
```

**Modify the status update branch:**
In the `else if (payload.status)` branch, add a special case for status "running" with metadata:

```typescript
} else if (payload.status) {
  // Special handling for "running" status with VM metadata
  if (payload.status === "running" && payload.server_id && payload.server_ip && payload.tailscale_ip) {
    await completeProvisioningWithMetadata({
      jobId: payload.job_id,
      metadata: {
        serverId: payload.server_id,
        serverIp: payload.server_ip,
        tailscaleIp: payload.tailscale_ip,
      },
    });
    console.log(`[GitHub Callback] Job ${payload.job_id} completed with VM metadata: server=${payload.server_id}`);
  } else {
    // Default status update (provisioning, failed, or running without metadata)
    await updateJobStatus({
      jobId: payload.job_id,
      status: payload.status,
      workflowRunId: payload.workflow_run_id,
      error: payload.error,
      failedStep: payload.failed_step,
    });
    console.log(`[GitHub Callback] Job ${payload.job_id} status -> ${payload.status}`);
  }
}
```

This means:
- `status: "running"` WITH server_id + server_ip + tailscale_ip → completeProvisioningWithMetadata (full path)
- `status: "running"` WITHOUT metadata → updateJobStatus (backward compatible)
- `status: "provisioning"` → updateJobStatus (unchanged)
- `status: "failed"` → updateJobStatus (unchanged)
- `type: "heartbeat"` → recordHeartbeat (unchanged)

Keep all other code unchanged: signature verification, JSON parsing, error handling, response format.
  </action>
  <verify>
`npx tsc --noEmit` passes. File imports `completeProvisioningWithMetadata` from queue. Payload type includes `server_id`, `server_ip`, `tailscale_ip` optional fields. Conditional branch routes "running" + metadata to completeProvisioningWithMetadata. Non-metadata "running" still uses updateJobStatus (backward compatible).
  </verify>
  <done>
GitHub callback handler routes success payloads with VM metadata to `completeProvisioningWithMetadata`, which updates the provisioning job, agent instance, and agent status atomically. Backward compatible with payloads missing metadata.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero new TypeScript errors
2. Callback handler accepts VM metadata in payload (server_id, server_ip, tailscale_ip)
3. completeProvisioningWithMetadata creates/updates agentInstances record
4. Agent status updated to "active" on successful provisioning
5. Backward compatible: status=running without metadata still works via updateJobStatus
6. All existing callback handler behavior preserved (heartbeat, provisioning, failed)
</verification>

<success_criteria>
When GitHub Actions workflow sends success callback with VM metadata, the database stores server_id, server_ip, and tailscale_ip in the agentInstances table. The agent transitions to "active" status. The provisioning job is marked "running" with completedAt timestamp.
</success_criteria>

<output>
After completion, create `.planning/phases/07-vm-provisioning-via-hetzner-api/07-03-SUMMARY.md`
</output>
