---
phase: 06-async-pipeline-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/provisioning/github-actions.ts
autonomous: true
user_setup:
  - service: github
    why: "Trigger GitHub Actions workflows via API"
    env_vars:
      - name: GITHUB_PAT
        source: "GitHub Settings -> Developer settings -> Personal access tokens -> Fine-grained tokens. Create token with permissions: Actions (read/write), Contents (read), Metadata (read). Scope to this repository only."
      - name: GITHUB_REPO_OWNER
        source: "GitHub repository owner (e.g. 'your-username' or 'your-org')"
      - name: GITHUB_REPO_NAME
        source: "GitHub repository name (e.g. 'aura')"
  - service: github-actions
    why: "Callback signature verification"
    env_vars:
      - name: GITHUB_CALLBACK_SECRET
        source: "Generate a random secret: openssl rand -hex 32. Add as GitHub Actions repository secret AND as Vercel environment variable."

must_haves:
  truths:
    - "Stripe checkout.session.completed webhook creates a provisioning job and returns 200 within 2 seconds"
    - "Duplicate Stripe events do not create duplicate provisioning jobs (idempotent)"
    - "GitHub Actions workflow is triggered automatically after job is queued"
    - "User with an in-progress provisioning job cannot start another"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Enhanced webhook handler that queues provisioning job on checkout.session.completed"
      contains: "enqueueProvisioningJob"
    - path: "src/lib/provisioning/github-actions.ts"
      provides: "GitHub Actions workflow_dispatch trigger"
      exports: ["triggerProvisioningWorkflow"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/provisioning/queue.ts"
      via: "enqueueProvisioningJob call in checkout.session.completed handler"
      pattern: "enqueueProvisioningJob"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/provisioning/github-actions.ts"
      via: "triggerProvisioningWorkflow call after job enqueue"
      pattern: "triggerProvisioningWorkflow"
    - from: "src/lib/provisioning/github-actions.ts"
      to: "https://api.github.com"
      via: "fetch to workflow_dispatch API"
      pattern: "actions/workflows.*dispatches"
---

<objective>
Enhance the Stripe webhook handler to queue provisioning jobs and trigger GitHub Actions workflows.

Purpose: Connect payment events to the provisioning pipeline. When a user completes checkout, the webhook handler creates a subscription, queues a provisioning job (idempotently), and triggers a GitHub Actions workflow to execute the provisioning steps. This is the "payment -> queue -> trigger" segment of the pipeline.

Output: Enhanced Stripe webhook route and GitHub Actions trigger module.
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-async-pipeline-foundation/06-RESEARCH.md
@.planning/phases/06-async-pipeline-foundation/06-01-SUMMARY.md
@src/app/api/webhooks/stripe/route.ts
@src/lib/stripe.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions trigger module</name>
  <files>src/lib/provisioning/github-actions.ts</files>
  <action>
Create `src/lib/provisioning/github-actions.ts` with the following:

**Environment variable validation (top of file):**
```typescript
function getGitHubConfig() {
  const token = process.env.GITHUB_PAT;
  const owner = process.env.GITHUB_REPO_OWNER;
  const repo = process.env.GITHUB_REPO_NAME;
  const callbackSecret = process.env.GITHUB_CALLBACK_SECRET;
  const appUrl = process.env.NEXT_PUBLIC_APP_URL;

  if (!token || !owner || !repo || !callbackSecret || !appUrl) {
    throw new Error("Missing GitHub Actions configuration. Required: GITHUB_PAT, GITHUB_REPO_OWNER, GITHUB_REPO_NAME, GITHUB_CALLBACK_SECRET, NEXT_PUBLIC_APP_URL");
  }

  return { token, owner, repo, callbackSecret, appUrl };
}
```

**Exported function `triggerProvisioningWorkflow(job)`:**
- Parameter: `job` — the provisioning job record (from provisioningJobs table type)
- Returns: `Promise<void>`
- Logic:
  1. Call `getGitHubConfig()` to validate env vars
  2. Make POST request to `https://api.github.com/repos/${owner}/${repo}/actions/workflows/provision-agent.yml/dispatches`
  3. Headers: `Accept: application/vnd.github+json`, `Authorization: Bearer ${token}`, `X-GitHub-Api-Version: 2022-11-28`
  4. Body:
     ```json
     {
       "ref": "main",
       "inputs": {
         "job_id": job.id,
         "agent_id": job.agentId,
         "region": job.region,
         "callback_url": `${appUrl}/api/webhooks/github`
       }
     }
     ```
  5. If response is not 204 (No Content), throw Error with response status and statusText
  6. Log: `console.log("[GitHub Actions] Triggered provisioning workflow for job ${job.id}")`

**Important notes:**
- Use native `fetch` (available in Node.js 18+, no extra dependency needed)
- The workflow_dispatch API returns 204 No Content on success — there is NO run ID returned. The workflow will post its run ID back via callback (Plan 03).
- Do NOT use GITHUB_TOKEN (that's the Actions runtime token, insufficient permissions). Use GITHUB_PAT (fine-grained PAT with Actions: write permission).
- Follow existing conventions: named exports, camelCase, console.log with `[GitHub Actions]` prefix
  </action>
  <verify>
1. `npx tsc --noEmit` passes without type errors
2. `triggerProvisioningWorkflow` is exported from the module
3. The fetch URL contains `actions/workflows/provision-agent.yml/dispatches`
  </verify>
  <done>
github-actions.ts exports triggerProvisioningWorkflow that POSTs to GitHub workflow_dispatch API with job_id, agent_id, region, and callback_url as inputs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance Stripe webhook to queue provisioning jobs</name>
  <files>src/app/api/webhooks/stripe/route.ts</files>
  <action>
Modify the existing Stripe webhook handler to add provisioning job creation in the `checkout.session.completed` case.

**New imports at top of file:**
```typescript
import { provisioningJobs, agents } from "@/lib/db/schema";
import { enqueueProvisioningJob, getJobByStripeEventId } from "@/lib/provisioning/queue";
import { triggerProvisioningWorkflow } from "@/lib/provisioning/github-actions";
```

**Modify the `checkout.session.completed` case:**

After the existing subscription upsert logic, add provisioning job creation:

```typescript
case "checkout.session.completed": {
  const session = event.data.object as Stripe.Checkout.Session;

  // 1. Existing: upsert subscription
  if (session.subscription && session.customer) {
    const sub = await stripe.subscriptions.retrieve(
      session.subscription as string
    );
    await upsertSubscription(sub);
  }

  // 2. NEW: Queue provisioning job (idempotent)
  const agentId = session.metadata?.agentId;
  const userId = session.metadata?.userId;
  const region = session.metadata?.region || "us-east";

  if (agentId && userId) {
    // Idempotency check: has this Stripe event already been processed?
    const existingJob = await getJobByStripeEventId(event.id);
    if (existingJob) {
      console.log(`[Stripe Webhook] Event ${event.id} already processed, skipping`);
      break;
    }

    try {
      // Enqueue the provisioning job
      const job = await enqueueProvisioningJob({
        agentId,
        userId,
        stripeEventId: event.id,
        region,
      });

      console.log(`[Stripe Webhook] Provisioning job ${job.id} queued for agent ${agentId}`);

      // Trigger GitHub Actions workflow (non-blocking try/catch)
      // If this fails, job stays "queued" and can be retried
      try {
        await triggerProvisioningWorkflow(job);
      } catch (triggerError) {
        console.error(`[Stripe Webhook] Failed to trigger workflow for job ${job.id}:`, triggerError);
        // Job stays queued — user can retry from dashboard (Phase 10)
        // Do NOT fail the webhook response — job is already saved
      }
    } catch (queueError) {
      // Log but don't fail webhook — may be concurrent provision error
      console.error(`[Stripe Webhook] Failed to queue provisioning:`, queueError);
    }
  }

  break;
}
```

**Critical design decisions reflected:**
- **Idempotency:** Check `getJobByStripeEventId(event.id)` before creating. Stripe retries webhooks for up to 3 days.
- **Non-blocking trigger:** The GitHub Actions trigger is wrapped in its own try/catch. If it fails, the job stays "queued" in database. The webhook still returns 200 to Stripe.
- **Speed:** The webhook handler must return 200 within 2 seconds (Vercel timeout + Stripe expectation). DB insert is fast (~50ms). GitHub API call is fast (~500ms). Well within limits.
- **Metadata dependency:** Requires `agentId`, `userId`, and optionally `region` in Stripe Checkout session metadata. The wizard step 4 (Phase 10 / existing code) must pass these when creating checkout session. For now, if metadata is missing, the webhook silently skips provisioning (no crash).
- **Concurrent provision:** `enqueueProvisioningJob` internally calls `checkConcurrentProvision` which throws if user has in-progress job. The error is caught and logged.

**Do NOT modify** the other event handlers (customer.subscription.updated, etc.) or the upsertSubscription function. Only modify the checkout.session.completed case.
  </action>
  <verify>
1. `npx tsc --noEmit` passes without type errors
2. The checkout.session.completed case calls `enqueueProvisioningJob` and `triggerProvisioningWorkflow`
3. The idempotency check (`getJobByStripeEventId`) is called before job creation
4. The GitHub Actions trigger is wrapped in a nested try/catch (non-blocking)
5. The webhook still returns `NextResponse.json({ received: true })` at the end
  </verify>
  <done>
Stripe webhook handler creates a provisioning job in database on checkout.session.completed, checks idempotency via stripeEventId, triggers GitHub Actions workflow, and returns 200 within 2 seconds. Existing subscription logic preserved.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full project compiles without type errors
2. Stripe webhook handler has idempotency check before job creation
3. GitHub Actions trigger module makes correct API call to workflow_dispatch
4. Webhook handler returns 200 even if GitHub trigger fails
</verification>

<success_criteria>
- Stripe webhook creates provisioning job on checkout.session.completed with idempotency
- GitHub Actions workflow_dispatch is triggered with job_id, agent_id, region, callback_url
- Webhook returns 200 within 2 seconds (no blocking on workflow execution)
- Concurrent provisioning per user is blocked at enqueue time
</success_criteria>

<output>
After completion, create `.planning/phases/06-async-pipeline-foundation/06-02-SUMMARY.md`
</output>
