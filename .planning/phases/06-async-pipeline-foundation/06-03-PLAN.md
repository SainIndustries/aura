---
phase: 06-async-pipeline-foundation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/webhooks/github/route.ts
  - .github/workflows/provision-agent.yml
autonomous: true

must_haves:
  truths:
    - "GitHub Actions workflow posts status callbacks to the API endpoint"
    - "Callback endpoint verifies HMAC signature before processing"
    - "Database reflects workflow status changes (queued -> provisioning -> running/failed)"
    - "Heartbeat signals keep the job alive during long-running provisioning"
    - "Workflow posts failure callback if any step fails"
  artifacts:
    - path: "src/app/api/webhooks/github/route.ts"
      provides: "Callback endpoint for GitHub Actions status updates"
      exports: ["POST"]
    - path: ".github/workflows/provision-agent.yml"
      provides: "GitHub Actions workflow with workflow_dispatch trigger and callback steps"
      contains: "workflow_dispatch"
  key_links:
    - from: ".github/workflows/provision-agent.yml"
      to: "src/app/api/webhooks/github/route.ts"
      via: "curl POST to callback_url input"
      pattern: "callback_url"
    - from: "src/app/api/webhooks/github/route.ts"
      to: "src/lib/provisioning/queue.ts"
      via: "updateJobStatus and recordHeartbeat calls"
      pattern: "updateJobStatus|recordHeartbeat"
---

<objective>
Create the GitHub Actions callback endpoint and provisioning workflow YAML.

Purpose: Complete the async pipeline by building the "response" path. The GitHub Actions workflow receives dispatch inputs, posts status callbacks (with HMAC signatures) to the API endpoint, and the endpoint updates job status in the database. This closes the loop: payment -> queue -> trigger -> workflow executes -> callback -> database updated.

Output: GitHub callback webhook route and provision-agent.yml workflow file (with placeholder provisioning steps for Phase 7-8 to fill in).
</objective>

<execution_context>
@/Users/danielhuynh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/danielhuynh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-async-pipeline-foundation/06-RESEARCH.md
@.planning/phases/06-async-pipeline-foundation/06-01-SUMMARY.md
@src/lib/provisioning/queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions callback webhook endpoint</name>
  <files>src/app/api/webhooks/github/route.ts</files>
  <action>
Create `src/app/api/webhooks/github/route.ts` — the callback endpoint that receives status updates from the GitHub Actions provisioning workflow.

**Imports:**
```typescript
import { NextResponse } from "next/server";
import crypto from "crypto";
import { updateJobStatus, recordHeartbeat } from "@/lib/provisioning/queue";
```

**HMAC Signature Verification function (internal, not exported):**
```typescript
function verifySignature(body: string, signature: string | null): boolean {
  if (!signature) return false;

  const secret = process.env.GITHUB_CALLBACK_SECRET;
  if (!secret) {
    console.error("[GitHub Callback] GITHUB_CALLBACK_SECRET not configured");
    return false;
  }

  const expectedSignature = crypto
    .createHmac("sha256", secret)
    .update(body)
    .digest("hex");

  // Use timingSafeEqual to prevent timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(signature, "hex"),
      Buffer.from(expectedSignature, "hex")
    );
  } catch {
    return false; // Different lengths or invalid hex
  }
}
```

**POST handler:**
```typescript
export async function POST(request: Request) {
  const body = await request.text();
  const signature = request.headers.get("x-signature");

  // Verify HMAC signature
  if (!verifySignature(body, signature)) {
    console.error("[GitHub Callback] Invalid signature");
    return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
  }

  let payload: {
    job_id: string;
    status?: "provisioning" | "running" | "failed";
    type?: "heartbeat";
    workflow_run_id?: string;
    error?: string;
    failed_step?: string;
  };

  try {
    payload = JSON.parse(body);
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  // Validate required field
  if (!payload.job_id) {
    return NextResponse.json({ error: "Missing job_id" }, { status: 400 });
  }

  try {
    // Handle heartbeat vs status update
    if (payload.type === "heartbeat") {
      await recordHeartbeat(payload.job_id);
      console.log(`[GitHub Callback] Heartbeat for job ${payload.job_id}`);
    } else if (payload.status) {
      await updateJobStatus({
        jobId: payload.job_id,
        status: payload.status,
        workflowRunId: payload.workflow_run_id,
        error: payload.error,
        failedStep: payload.failed_step,
      });
      console.log(`[GitHub Callback] Job ${payload.job_id} status -> ${payload.status}`);
    } else {
      return NextResponse.json({ error: "Missing status or type" }, { status: 400 });
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("[GitHub Callback] Error processing callback:", error);
    return NextResponse.json(
      { error: "Failed to process callback" },
      { status: 500 }
    );
  }
}
```

**Key design points:**
- HMAC verification using `crypto.timingSafeEqual()` (prevents timing attacks — see research pitfall 6)
- Supports two callback types: `status update` (with status field) and `heartbeat` (with type: "heartbeat")
- Uses `request.text()` for raw body (needed for HMAC verification, consistent with Stripe webhook pattern)
- Returns 401 on bad signature, 400 on malformed payload, 200 on success
- Follows existing webhook handler conventions (see Stripe webhook route)
  </action>
  <verify>
1. `npx tsc --noEmit` passes without type errors
2. POST handler is exported from `src/app/api/webhooks/github/route.ts`
3. HMAC verification uses `crypto.timingSafeEqual`
4. Handler supports both heartbeat and status update payloads
  </verify>
  <done>
GitHub callback endpoint verifies HMAC signatures, handles status updates and heartbeats, and updates job status in database. Returns 200 on success, 401 on bad signature.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub Actions provisioning workflow</name>
  <files>.github/workflows/provision-agent.yml</files>
  <action>
Create `.github/workflows/provision-agent.yml` — the workflow that executes when triggered by `workflow_dispatch`.

**Important:** Create the `.github/workflows/` directory if it doesn't exist.

**Workflow contents:**

```yaml
name: Provision Agent

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Provisioning job ID'
        required: true
        type: string
      agent_id:
        description: 'Agent ID to provision'
        required: true
        type: string
      region:
        description: 'Deployment region (e.g. us-east, eu-central)'
        required: true
        type: string
      callback_url:
        description: 'URL to POST status callbacks to'
        required: true
        type: string

jobs:
  provision:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Send provisioning callback
        run: |
          BODY='{"job_id":"${{ inputs.job_id }}","status":"provisioning","workflow_run_id":"${{ github.run_id }}"}'
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent provisioning callback for job ${{ inputs.job_id }}"

      - name: Heartbeat loop
        run: |
          # Send heartbeats every 60 seconds in background
          while true; do
            sleep 60
            BODY='{"job_id":"${{ inputs.job_id }}","type":"heartbeat"}'
            SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

            curl -sf -X POST "${{ inputs.callback_url }}" \
              -H "Content-Type: application/json" \
              -H "X-Signature: $SIGNATURE" \
              -d "$BODY" || true
          done &
          HEARTBEAT_PID=$!

          # Save PID for cleanup
          echo "$HEARTBEAT_PID" > /tmp/heartbeat_pid
          echo "Heartbeat loop started (PID: $HEARTBEAT_PID)"

      - name: Provision VM (placeholder)
        run: |
          echo "============================================"
          echo "PLACEHOLDER: VM Provisioning"
          echo "============================================"
          echo "Job ID: ${{ inputs.job_id }}"
          echo "Agent ID: ${{ inputs.agent_id }}"
          echo "Region: ${{ inputs.region }}"
          echo ""
          echo "Phase 7 will implement:"
          echo "  - Hetzner API: Create VM"
          echo "  - Wait for VM to be ready"
          echo "  - Store server_id, server_ip"
          echo ""
          echo "Phase 8 will implement:"
          echo "  - Ansible: Configure VM"
          echo "  - Install Docker, agent runtime"
          echo "  - Tailscale enrollment"
          echo ""
          echo "Simulating work (5 seconds)..."
          sleep 5
          echo "Placeholder provisioning complete."

      - name: Stop heartbeat
        if: always()
        run: |
          if [ -f /tmp/heartbeat_pid ]; then
            kill $(cat /tmp/heartbeat_pid) 2>/dev/null || true
            echo "Heartbeat loop stopped"
          fi

      - name: Send success callback
        if: success()
        run: |
          BODY='{"job_id":"${{ inputs.job_id }}","status":"running"}'
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent success callback for job ${{ inputs.job_id }}"

      - name: Send failure callback
        if: failure()
        run: |
          BODY='{"job_id":"${{ inputs.job_id }}","status":"failed","error":"Workflow failed at step: ${{ job.status }}","failed_step":"provision"}'
          SIGNATURE=$(echo -n "$BODY" | openssl dgst -sha256 -hmac "${{ secrets.GITHUB_CALLBACK_SECRET }}" -hex | awk '{print $NF}')

          curl -sf -X POST "${{ inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -H "X-Signature: $SIGNATURE" \
            -d "$BODY"

          echo "Sent failure callback for job ${{ inputs.job_id }}"
```

**Key design points:**
- `workflow_dispatch` trigger with typed inputs (per research recommendation over repository_dispatch)
- `timeout-minutes: 15` (conservative, per user decision: minimum 10 minutes, Claude chose 15)
- HMAC signature on every callback (matches verification in callback endpoint)
- Heartbeat loop runs in background, sends heartbeat every 60 seconds
- Heartbeat is cleaned up via `if: always()` step (runs even on failure)
- Placeholder provisioning step that Phase 7 and 8 will replace with real Hetzner API + Ansible calls
- Separate success and failure callback steps using `if: success()` and `if: failure()` conditions
- `curl -sf` flag: `-s` for silent, `-f` for fail on HTTP errors (so workflow detects callback failures)
- Uses `secrets.GITHUB_CALLBACK_SECRET` repository secret (user must configure this)

**Required GitHub Actions secrets (user must configure):**
- `GITHUB_CALLBACK_SECRET` — same value as the Vercel environment variable
  </action>
  <verify>
1. `.github/workflows/provision-agent.yml` exists and is valid YAML
2. Workflow has `workflow_dispatch` trigger with 4 required inputs
3. Workflow sends provisioning, heartbeat, success, and failure callbacks
4. All callbacks include HMAC signature in X-Signature header
5. Heartbeat loop is started and cleaned up properly
6. `timeout-minutes: 15` is set on the job
  </verify>
  <done>
GitHub Actions workflow triggers on workflow_dispatch with job_id, agent_id, region, callback_url inputs. Sends provisioning callback, runs heartbeat loop, executes placeholder provisioning step, sends success/failure callback. All callbacks HMAC-signed.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full project compiles without type errors
2. GitHub callback endpoint handles both heartbeat and status update payloads
3. HMAC signature verification uses timing-safe comparison
4. Workflow YAML is syntactically valid
5. Callback payloads in workflow match the schema expected by the callback endpoint
</verification>

<success_criteria>
- GitHub Actions workflow posts status updates to callback endpoint with HMAC signatures
- Callback endpoint verifies signatures and updates job status in database
- Heartbeat mechanism keeps jobs alive during long-running operations
- Workflow distinguishes success (status=running) from failure (status=failed)
- Failure callback includes error message and failed step
</success_criteria>

<output>
After completion, create `.planning/phases/06-async-pipeline-foundation/06-03-SUMMARY.md`
</output>
